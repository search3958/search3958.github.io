<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI & Developer Future (Hyper-Sync)</title>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        :root { --primary-color: #007bff; --bg-color: #000; --ui-bg: rgba(40, 40, 40, 0.85); }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: var(--bg-color); font-family: 'Pretendard', sans-serif; }
        
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; color: white; }
        .progress-container { width: 300px; height: 4px; background: #333; margin-top: 20px; border-radius: 2px; overflow: hidden; }
        #progress-bar { width: 0%; height: 100%; background: var(--primary-color); transition: width 0.2s; }

        #slide-container { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden; position: relative; }
        
        /* 基本スタイル。transition自体はJSで上書きするため、ここでは位置固定のみ */
        #display-image { 
            max-width: 100%; 
            max-height: 100%; 
            object-fit: contain; 
            position: absolute;
            z-index: 2;
        }

        #memo-box { position: absolute; top: 30px; left: 30px; width: 340px; max-height: 60vh; padding: 24px; background: rgba(255, 255, 255, 0.98); border-radius: 16px; box-shadow: 0 15px 35px rgba(0,0,0,0.5); display: none; z-index: 100; cursor: move; border-top: 5px solid var(--primary-color); }
        #memo-text { margin-top: 10px; font-size: 16px; line-height: 1.7; color: #222; }

        .controls { position: fixed; bottom: 30px; right: 30px; display: flex; gap: 8px; opacity: 0; transition: 0.3s; z-index: 1000; }
        .controls-hitbox { position: fixed; bottom: 0; right: 0; width: 200px; height: 150px; z-index: 999; }
        .controls-hitbox:hover + .controls, .controls:hover { opacity: 1; }
        button { padding: 10px 16px; cursor: pointer; border: none; border-radius: 8px; background: var(--ui-bg); color: white; font-size: 13px; }
        button:hover { background: var(--primary-color); }

        #sync-status { position: fixed; top: 20px; right: 20px; font-size: 10px; color: #4caf50; display: flex; align-items: center; gap: 5px; opacity: 0.7; }
        .dot { width: 8px; height: 8px; background: #4caf50; border-radius: 50%; }
        #page-num { position: fixed; bottom: 30px; left: 30px; color: rgba(255,255,255,0.4); font-size: 13px; }
    </style>
</head>
<body>

<div id="loader">
    <div id="load-status">Connecting to Firebase...</div>
    <div class="progress-container"><div id="progress-bar"></div></div>
</div>

<div id="sync-status"><div class="dot"></div> REALTIME SYNC ON</div>

<div id="slide-container">
    <img id="display-image" src="">
</div>

<div id="memo-box">
    <strong style="color:var(--primary-color)">Slide Memo <span id="memo-idx">1</span></strong>
    <div id="memo-text"></div>
</div>

<div id="page-num">0 / 20</div>
<div class="controls-hitbox"></div>
<div class="controls">
    <button onclick="prevImage()">戻る</button>
    <button onclick="nextImage()">전진</button>
    <button onclick="toggleMemo()">メモを見る</button>
</div>

<script>
    // --- Firebase 設定 ---
    const firebaseConfig = {
        apiKey: "AIzaSyDjMhqOjKoGgzvUsn0QXm2sX-epnw7yhhc",
        authDomain: "tangle-sns.firebaseapp.com",
        databaseURL: "https://tangle-sns-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "tangle-sns",
        storageBucket: "tangle-sns.firebasestorage.app",
        messagingSenderId: "248303876559",
        appId: "1:248303876559:web:b8c6b6a28cdc93fa3a3aba",
        measurementId: "G-HMDE0QX8ZM"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const slideRef = db.ref('presentation/currentSlide');

    const imageList = [1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21];
    const memos = [
        "生成AIの時代，人間の開発者が消えるのかについて調べてきた。よろしく。",
        "今回，ソフトウェアとハードウェア開発者の今と今後に焦点を当てて話していきたい。",
        "まず結論を言うと生き残れる。ただ，基礎知識と新しい知識を継続的に取り込むことが必要。ハードウェア開発者は完全に生き残れると考えている。実際に数回ほど設計したが，AIができる部分は少ないと感じた。",
        "また，否定するよりもAIを使ってみることが重要だと私は思う。何か始めたいことがあったとして，それをするときにAIに手助けや作ってもらって，地味に自分で作れるように学習していくのが大事だと思う。",
        "自分はAIによってかなり知識も身についた。23年にAIのみで色々作り始め、24年には基礎知識もついてきて配信を開始。学校内でもWebサービスを使ってもらっている。25年には本格開発し、AIで数を作ってきたおかげでWebアプリの基礎知識はほぼ身についた。今はアプリ開発も始めている。",
        "まず，AIに関して。気付いたことを話していく。",
        "簡単なWebアプリなどなら問題ないが，複雑なものをAIに全部を任せたら確実に事故る。",
        "具体的に言うと通信エラーやデータがないことを一切想定しないことで，例外が多発したりする。指示なしだと拡張が難しかったり、共通化が不十分だったりする。",
        "ただ，その辺も優秀なAIはちゃんとしてくれる。GLM, 千问, Claudeなんかはかなり優秀。Geminiも速度がバケモンなので使うことが多い。",
        "それでも全てできるわけではなく，やっぱりテキストベースの作業が得意。仕様書の解説や骨組み生成、バグ解析など。ただ、バグの特定は人間が行った方が効率的な場合もある。",
        "細かいバグは苦手っぽい。他にもPCB設計, GUIなどのグラフィック系も苦手な印象。",
        "AIは知識レベルだけなら強い。なのでAIとの競争は諦めた方がいい。少なくともソフトウェア開発においては。",
        "だが仕事全部を奪われるわけではなく，共存してこそ力が発揮できる。プロンプト力を上げるより、AIに作業を与え、自分は構造や「どうすべきか」を考えることで成長のチャンスを得られる。",
        "開発速度はかなり高速になる。実際に作ってから学ぶ方が構造を理解しやすい。今はコーディング（ライティング）よりリーディング（読み取り）ができれば困らないレベル。",
        "ただしAIの知識が常に最新とは限らない。AIをどう使うか、手作業とどう使い分けるかが重要なスキルになる。",
        "例えば動画制作で、実写かVFXかAI生成か. 場面やこだわりによって選択が変わるように、プログラミングでも使い分けが重要。",
        "AIスキル以前に、自分に害がないことには何でもチャレンジした方がいい。その知識は再チャレンジする時に絶対役に立つはず。",
        "明確な目標は必要。3D制作やアプリ開発も、作りたいものを決めて再チャレンジすることで気軽に作れるようになった。諦めたことがあればもう一度やってみるべき。",
        "今関係ない面白そうな技術書を読むのも、意外と今後役立ちやすい。全てをAIに任せきりにすると、トラブル時の対応が難しくなる。",
        "まとめ：AIは文章系が得意で、共存を目指すべき。目標を立て、知識を得ることを目的に学習することで、より役立つことが多くなる。고맙습니다!"
    ];

    let currentIndex = 0;
    const preloadedImages = [];
    let loadedCount = 0;
    let slideDirection = 'right';

    // Firebase からの状態受信
    slideRef.on('value', (snapshot) => {
        const val = snapshot.val();
        if (val !== null && val !== currentIndex) {
            slideDirection = (val > currentIndex) ? 'right' : 'left';
            currentIndex = val;
            if (loadedCount === imageList.length) updateDisplay();
        }
    });

    function preloadAllImages() {
        const progressBar = document.getElementById('progress-bar');
        const statusText = document.getElementById('load-status');
        imageList.forEach((num, index) => {
            const img = new Image();
            img.src = `${num}.webp`;
            img.onload = () => {
                loadedCount++;
                const percent = Math.floor((loadedCount / imageList.length) * 100);
                progressBar.style.width = percent + '%';
                statusText.innerText = `Assets Loading... ${percent}%`;
                if (loadedCount === imageList.length) startPresentation();
            };
            preloadedImages[index] = img;
        });
    }

    function startPresentation() {
        document.getElementById('loader').style.display = 'none';
        updateDisplay();
    }

    // --- Hyper-Sync アニメーションロジック ---
    function updateDisplay() {
        const container = document.getElementById('slide-container');
        const currentImg = document.getElementById('display-image');
        
        // アニメーション設定
        const easing = "cubic-bezier(0.8, 0, 0, 1)";
        const duration = "0.6s";
        const moveDistance = 10; // 10vw

        // 1. クローンを作成して「古いスライド」として背後に残す
        const clone = currentImg.cloneNode(true);
        clone.id = ""; 
        clone.style.zIndex = "1";
        container.appendChild(clone);

        // 2. 本物の要素（新しいスライド）を準備
        currentImg.style.transition = "none";
        currentImg.src = preloadedImages[currentIndex].src;
        currentImg.style.opacity = "0";

        // 進むなら右、戻るなら左に初期配置
        const startPos = (slideDirection === 'right') ? moveDistance : -moveDistance;
        currentImg.style.transform = `translateX(${startPos}vw)`;

        // 3. ブラウザにスタイルの変更を強制的に認識させる
        currentImg.offsetHeight;

        // 4. アニメーション開始：新旧スライドを同時に動かす
        requestAnimationFrame(() => {
            // 新スライドの進入
            currentImg.style.transition = `all ${duration} ${easing}`;
            currentImg.style.opacity = "1";
            currentImg.style.transform = "translateX(0)";

            // 旧スライド（クローン）の退出（進入方向と逆に逃げる）
            clone.style.transition = `all ${duration} ${easing}`;
            clone.style.opacity = "0";
            clone.style.transform = `translateX(${-startPos}vw)`;

            // アニメーション完了後にクローンを消去
            setTimeout(() => {
                if(clone.parentNode === container) container.removeChild(clone);
            }, 700); // durationより少し長めに設定
        });

        // UI情報の更新
        document.getElementById('memo-text').innerText = memos[currentIndex] || "";
        document.getElementById('memo-idx').innerText = currentIndex + 1;
        document.getElementById('page-num').innerText = `${currentIndex + 1} / ${imageList.length}`;
    }

    function nextImage() {
        if (currentIndex < imageList.length - 1) {
            slideDirection = 'right';
            currentIndex++;
            slideRef.set(currentIndex);
            updateDisplay();
        }
    }

    function prevImage() {
        if (currentIndex > 0) {
            slideDirection = 'left';
            currentIndex--;
            slideRef.set(currentIndex);
            updateDisplay();
        }
    }

    function toggleMemo() {
        const box = document.getElementById('memo-box');
        box.style.display = (box.style.display === "block") ? "none" : "block";
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === "ArrowRight" || e.key === " ") { e.preventDefault(); nextImage(); }
        if (e.key === "ArrowLeft") { e.preventDefault(); prevImage(); }
        if (e.key === "m" || e.key === "M") toggleMemo();
    });

    window.onload = preloadAllImages;
</script>
</body>
</html>