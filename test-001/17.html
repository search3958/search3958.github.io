<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3å˜èªå…¨çµåˆï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾å¿œç‰ˆï¼‰</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background: #f0f2f5; }
        .card { max-width: 600px; margin: auto; background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .status-box { background: #fffbe6; border: 1px solid #ffe58f; padding: 15px; border-radius: 8px; margin: 20px 0; }
        #log { background: #222; color: #34a853; padding: 10px; height: 120px; overflow-y: auto; font-family: monospace; font-size: 12px; margin-top: 10px; }
        button { background: #1a73e8; color: white; border: none; padding: 15px; border-radius: 6px; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold; }
        button:disabled { background: #ccc; }
        #resumeBtn { background: #ff4d4f; display: none; margin-top: 10px; }
        .stat { font-size: 18px; font-weight: bold; color: #1a73e8; }
    </style>
</head>
<body>

<div class="card">
    <h2>3å˜èª å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³çµåˆ</h2>
    <p>2GBã”ã¨ã«åˆ†å‰²ã—ã€å®‰å…¨ã«ä¿å­˜ã—ã¾ã™ã€‚</p>

    <input type="file" id="fileInput" accept=".txt">
    <hr>
    <button id="startBtn">1. å‡¦ç†ã‚’é–‹å§‹ã™ã‚‹</button>
    <button id="resumeBtn">2. æ¬¡ã®ä¿å­˜å…ˆã‚’æŒ‡å®šã—ã¦ç¶šè¡Œ</button>

    <div class="status-box">
        <div>ç”Ÿæˆæ¸ˆã¿: <span id="totalLines" class="stat">0</span> ãƒ‘ã‚¿ãƒ¼ãƒ³</div>
        <div>ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«: <span id="curSize" class="stat">0</span> MB</div>
        <div id="log">ãƒ­ã‚°: æº–å‚™å®Œäº†</div>
    </div>
</div>

<script>
    const fileInput = document.getElementById('fileInput');
    const startBtn = document.getElementById('startBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const log = document.getElementById('log');
    const curSizeDisp = document.getElementById('curSize');
    const totalLinesDisp = document.getElementById('totalLines');

    const MAX_PART_SIZE = 6 * 1024 * 1024 * 1024; 
    const BATCH_SIZE = 30000;

    let writable;
    let fileCount = 1;
    let currentPartBytes = 0;
    let totalLines = 0;
    let words = [];
    let state = { i: 0, j: 0, k: 0 }; // ã©ã“ã¾ã§å‡¦ç†ã—ãŸã‹ä¿å­˜

    function addLog(msg) {
        log.innerHTML += `> ${msg}<br>`;
        log.scrollTop = log.scrollHeight;
    }

    // ä¿å­˜å…ˆã‚’é¸æŠã—ã¦Writableã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚‹
    async function getWritable() {
        try {
            const handle = await window.showSaveFilePicker({
                suggestedName: `patterns_part${fileCount}.txt`
            });
            fileCount++;
            currentPartBytes = 0;
            return await handle.createWritable();
        } catch (e) {
            addLog("ä¿å­˜ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
            return null;
        }
    }

    async function runProcess() {
        startBtn.style.display = 'none';
        resumeBtn.style.display = 'none';
        
        const encoder = new TextEncoder();
        let batchBuffer = "";
        let batchCount = 0;
        const n = words.length;

        // å†é–‹å¯èƒ½ãª3é‡ãƒ«ãƒ¼ãƒ—
        for (; state.i < n; state.i++) {
            for (; state.j < n; state.j++) {
                for (; state.k < n; state.k++) {
                    
                    batchBuffer += words[state.i] + words[state.j] + words[state.k] + "\n";
                    batchCount++;
                    totalLines++;

                    if (batchCount >= BATCH_SIZE) {
                        const data = encoder.encode(batchBuffer);

                        // 2GBã‚’è¶…ãˆãã†ãªå ´åˆ
                        if (currentPartBytes + data.length > MAX_PART_SIZE) {
                            await writable.close();
                            addLog("2GBã«é”ã—ã¾ã—ãŸã€‚æ¬¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚");
                            resumeBtn.style.display = 'block'; // ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ã¦å¾…æ©Ÿ
                            return; // ä¸€æ—¦é–¢æ•°ã‚’æŠœã‘ã‚‹
                        }

                        await writable.write(data);
                        currentPartBytes += data.length;
                        batchBuffer = "";
                        batchCount = 0;

                        if (totalLines % 5000 === 0) {
                            totalLinesDisp.textContent = totalLines.toLocaleString();
                            curSizeDisp.textContent = Math.floor(currentPartBytes / (1024 * 1024));
                        }
                    }
                }
                state.k = 0; // å†…å´ã®ãƒ«ãƒ¼ãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
            }
            state.j = 0; // ä¸­é–“ã®ãƒ«ãƒ¼ãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
        }

        if (batchBuffer) await writable.write(encoder.encode(batchBuffer));
        await writable.close();
        addLog("ğŸ‰ å…¨ã¦ã®å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸï¼");
    }

    startBtn.addEventListener('click', async () => {
        if (!fileInput.files[0]) return alert('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
        
        const text = await fileInput.files[0].text();
        words = text.split(/\r?\n/).map(s => s.trim()).filter(s => s !== "");
        addLog(`${words.length}å˜èªèª­ã¿è¾¼ã¿å®Œäº†ã€‚`);

        writable = await getWritable();
        if (writable) runProcess();
    });

    resumeBtn.addEventListener('click', async () => {
        writable = await getWritable();
        if (writable) runProcess();
    });
</script>
</body>
</html>