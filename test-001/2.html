<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>uiscript-v2 Parser</title>
<style>
  uiscript-v2 {
    display: none;
  }
</style>
</head>
<body>

<!-- ğŸ‘‡ DSLæ§‹æ–‡ã‚’ã“ã“ã«æ›¸ãã ã‘ -->
<uiscript-v2>
div class(main){
  a href(#){
    "Hello"br;"World"
  };"ã“ã‚“ã«ã¡ã¯"
};
</uiscript-v2>

<script>
/**
 * DSLæ§‹æ–‡ã‚’HTMLæ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹
 */
function parseDSLtoHTML(input) {
  try {
    if (typeof input !== "string" || input.trim() === "") {
      console.warn("âš ï¸ å…¥åŠ›ãŒç©ºã€ã¾ãŸã¯æ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
      return "";
    }

    const parseBlock = (code) => {
      let html = "";
      let i = 0;

      while (i < code.length) {
        if (/\s/.test(code[i])) {
          i++;
          continue;
        }

        const tagMatch = /^[a-zA-Z0-9:-]+/.exec(code.slice(i));
        if (!tagMatch) {
          const textMatch = /^"([^"]*)"/.exec(code.slice(i));
          if (textMatch) {
            html += textMatch[1];
            i += textMatch[0].length;
          } else {
            i++;
          }
          continue;
        }

        const tag = tagMatch[0];
        i += tag.length;

        // å±æ€§
        let attrs = "";
        while (true) {
          const attrMatch = /^\s*([a-zA-Z0-9:-]+)\(([^)]*)\)/.exec(code.slice(i));
          if (!attrMatch) break;
          const [, key, value] = attrMatch;
          attrs += ` ${key}="${value.replace(/"/g, '&quot;')}"`;
          i += attrMatch[0].length;
        }

        // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
        if (code[i] === "{") {
          let depth = 1;
          let j = i + 1;
          while (j < code.length && depth > 0) {
            if (code[j] === "{") depth++;
            else if (code[j] === "}") depth--;
            j++;
          }
          if (depth !== 0) {
            console.error(`âš ï¸ ã‚¿ã‚° <${tag}> ã«å¯¾å¿œã™ã‚‹ '}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
            break;
          }
          const inner = code.slice(i + 1, j - 1);
          const innerHTML = parseBlock(inner);
          html += `<${tag}${attrs}>${innerHTML}</${tag}>`;
          i = j;
        } else {
          html += `<${tag}${attrs}></${tag}>`;
        }

        // ã‚»ãƒŸã‚³ãƒ­ãƒ³ã§æ¬¡ã¸
        const nextSemi = /^\s*;/.exec(code.slice(i));
        if (nextSemi) i += nextSemi[0].length;
      }

      // æ®‹ã‚Šã®æ–‡å­—åˆ— (ä¾‹: "ã“ã‚“ã«ã¡ã¯")
      const extraTextMatch = /"([^"]*)"/g;
      let text;
      while ((text = extraTextMatch.exec(code)) !== null) {
        html += text[1];
      }

      return html;
    };

    const result = parseBlock(input);
    console.log("âœ… HTMLç”ŸæˆæˆåŠŸ:", result);
    return result;
  } catch (e) {
    console.error("âŒ è§£æã‚¨ãƒ©ãƒ¼:", e);
    return "";
  }
}

/**
 * ã‚«ã‚¹ã‚¿ãƒ è¦ç´  <uiscript-v2>
 */
class UIScriptV2 extends HTMLElement {
  connectedCallback() {
    const content = this.textContent.trim();
    if (!content) {
      console.warn("âš ï¸ <uiscript-v2> ã«å†…å®¹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚");
      return;
    }

    console.log("ğŸ§© <uiscript-v2> è§£æé–‹å§‹");
    const html = parseDSLtoHTML(content);

    const container = document.createElement("div");
    container.innerHTML = html;

    if (this.nextSibling) {
      this.parentNode.insertBefore(container, this.nextSibling);
    } else {
      this.parentNode.appendChild(container);
    }

    console.log("âœ… <uiscript-v2> å‡¦ç†å®Œäº†: HTMLã‚’æŒ¿å…¥ã—ã¾ã—ãŸã€‚");
  }
}

customElements.define("uiscript-v2", UIScriptV2);
</script>

</body>  <script src="check.js"></script>
</html>
